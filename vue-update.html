<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-dark.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/tomorrow.css" />
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>vue-update</title>
</head>

<body>
<div id="container">
  <div class="inner">
    <header>
        <h1>简单例子来窥探一下vue update的过程</h1>
        <h2>ctyunaw</h2>
    </header>
    <section id="downloads" class="clearfix">
        <a href="https://github.com/moumoutang" id="view-on-github" class="button"><span>View on GitHub</span></a>
    </section>
    <hr>
    <section id="main_content">
    <p>
      之前有一篇大概讲了讲mount的过程：<a href="/vue-mount">简单例子来窥探一下vue mount的过程</a>
      <br>
      还接着那个例子来说，为了看到update过程，将click的响应稍微改动一下
    </p>
    <pre>
    <code>
      haha: function(){
        this.currentBranch = "develop"
      }
    </code>
    </pre>
    <p>
      因为是设值，所以自然跳到了对应的set方法<br>
      没有相对应的setter，需要observe，但是因为只是一个字符串值，不需要进行监听，
      如果是object或者数组等引用类型的值就需要加上新的监听<br>
      到了关键的dep.notify()<br><br>
      那么此时dep的值是什么呢？<br>
      我们回顾上一次讲mount的时候，在执行eval函数的时候会调用到get句柄，在此时给每个被监听的值上加了watcher<br>
    </p>
    <pre>
      <code>
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      ...
    },
    set: function reactiveSetter (newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if ("development" !== 'production' && customSetter) {
        customSetter();
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = observe(newVal);
      dep.notify();
    }
  });
      </code>
    </pre>
    <img src="images/vue/2017-04-20_14-52-14.png" />
    <p>
    我们会发现对于currentBranch有两个watcher <br>
    怎么会有两个咧？<br>
    原来前面还有个watch。。。<br>
    用户自定义的watcher是先init于render形成的watcher的<br>
    </p>
    <pre>
      <code>
  watch: {
    currentBranch: 'fetchData'
  }
      </code>
    </pre>
    <p>
      接下来就是调用每一个watcher的update方法：
    </p>
  <pre>
    <code>
  Dep.prototype.notify = function notify () {
    // stabilize the subscriber list first
    var subs = this.subs.slice();
    for (var i = 0, l = subs.length; i < l; i++) {
      subs[i].update();
    }
  };
    </code>
  </pre>
  <hr>
  <p>
    如果不是lazy 或者 sync同步的,则将现在的watcher 塞入一个队列中<br>
    然后执行nextTick函数<br>
    我们先不看nextTick，先看看
  </p>
  <pre>
    <code>
  Watcher.prototype.update = function update () {
    /* istanbul ignore else */
    if (this.lazy) {
      this.dirty = true;
    } else if (this.sync) {
      this.run();
    } else {
      queueWatcher(this);
    }
  };

  function queueWatcher (watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i >= 0 && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(Math.max(i, index) + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;
      nextTick(flushSchedulerQueue);
    }
  }
}
    </code>
  </pre>
    <hr>
  <p>
    flushSchedulerQueue的注释很有意思，给了很多信息:<br><br>
    1.组件更新是有顺序的，先更新祖先节点然后再更新孩子节点，它们的id watcher在初始化的时候也一定时有顺序的<br><br>
    2.用户定义的watcher的运行顺序一定是高于render的watcher，这是在初始化的时候自定义的wather是先与render的watcher<br><br>
    3.如果一个组件在父组件的watcher的运行期间被销毁，则它的watcher也会跳过<br><br>
    4.不要缓存队列的length，因为随时可能有新的wather入队<br><br>
    5.在dev环境中会检查回环<br>

  </p>
    <pre>
      <code>
function flushSchedulerQueue () {
  flushing = true;
  var watcher, id, vm;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  //    组件更新是有顺序的，先更新祖先节点然后再更新孩子节点，它们的id在初始化的时候也一定时有顺序的
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) { return a.id - b.id; });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if ("development" !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > config._maxUpdateCount) {
        warn(
          'You may have an infinite update loop ' + (
            watcher.user
              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
              : "in a component render function."
          ),
          watcher.vm
        );
        break
      }
    }
  }
      </code>
    </pre>
    <hr>

    </section>
<footer>
    This page was generated by <a href="https://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
</footer>
<script type="text/javascript" src="https://highlightjs.org/static/highlight.site.pack.js"></script>
<script type="text/javascript">
hljs.initHighlightingOnLoad()
</script>
</div>
</div>
</body>

</html>
