<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-dark.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/tomorrow.css" />
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>vue-mount</title>
</head>

<body>
<div id="container">
  <div class="inner">
    <header>
        <h1>简单例子来窥探一下vue mount的过程</h1>
        <h2>ctyunaw</h2>
    </header>
    <section id="downloads" class="clearfix">
        <a href="https://github.com/moumoutang" id="view-on-github" class="button"><span>View on GitHub</span></a>
    </section>
    <hr>
    <section id="main_content">
    <p>
        我们就从vue官方的一个例子开始看看，是怎么样一步步渲染出来的，下一篇讲讲怎么样子updata的， 例子很简单：
        <br>
        因为想看看事件绑定，所以就随便加了个click看看
        <br>
        ps: 本文只针对于生产环境中，非sever render模式
    </p>
    模板：
    <img class="example" src="images/vue/html.png" />
    JS：
    <pre>
      <code class="javascript">
var demo = new Vue({
    el: '#demo',
    data: {
      branches: ['master', 'dev'],
      currentBranch: 'master',
      commits: null
    },
    beforeCreate: function(){
      console.log('beforeCreate')
    },
    created: function () {
      this.fetchData()
    },
    watch: {
      currentBranch: 'fetchData'
    },
    filters: {
      truncate: function (v) {
        var newline = v.indexOf('\n')
        return newline > 0 ? v.slice(0, newline) : v
      },
      formatDate: function (v) {
        return v.replace(/T|Z/g, ' ')
      }
    },
    methods: {
      fetchData: function () {
        var xhr = new XMLHttpRequest()
        var self = this
        xhr.open('GET', apiURL + self.currentBranch)
        xhr.onload = function () {
          self.commits = JSON.parse(xhr.responseText)
          console.log(self.commits[0].html_url)
        }
        xhr.send()
      },
      haha: function(){
        console.log("haha")
      }
    }
  })
  </code>
</pre>
<p>
  我们跳出之前种种的init行为直接来看看,如下图所示，直接看 vm.$mount(vm.$options.el);这步骤 之前的各种init也都执行过了
</p>
<pre>
  <code class="javascript">
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if ("development" !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure(((vm._name) + " init"), startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    } 
  </code>
</pre>
<p>
  关键部分，我们可以看到直到 ’mounted‘钩子被执行的时候，动作就只是new了一个watcher，其他什么都没做，
  那么这个watcher是什么呢？  watcher其实是vue中一个非常重要的东西，那些数据的监听最终执行的都是watcher
</p>
<pre>
  <code>
    ....

    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };

    vm._watcher = new Watcher(vm, updateComponent, noop);

    ...

    vm._isMounted = true;
    callHook(vm, 'mounted');
  </code>
</pre>
构造函数：
<pre>
  <code>
   Watcher的构造函数：

    var Watcher = function Watcher (
      vm,
      expOrFn,
      cb,
      options
    ) {
    
    ...

    //将updateComponent 设置为getter
    this.getter = expOrFn;

    ...
    //执行get()
    this.value = this.lazy
    ? undefined
    : this.get();

  </code>
</pre>
get函数：
<pre>
  <code>
  Watcher.prototype.get = function get () {

  //Dep.target 是全局唯一的，每次只能指向watcher
  //function pushTarget (_target) {
  //  if (Dep.target) { targetStack.push(Dep.target); }
  //  Dep.target = _target;
  //}

  pushTarget(this);
  var value;
  var vm = this.vm;
  if (this.user) {
    try {
      //执行上文的updateComponent
      value = this.getter.call(vm, vm);
    } catch (e) {
      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
    }
  } else {
    value = this.getter.call(vm, vm);
  }
  // "touch" every property so they are all tracked as
  // dependencies for deep watching
  if (this.deep) {
    traverse(value);
  }

  //从dep队列里pop出来一个wathcer替换target
  popTarget();
  this.cleanupDeps();
  return value
};
  </code>
</pre>
<p>
vnode是vm._render()方法的返回值 <br>
这是初始的模板字符串： 

</p>
<img class="example" src="images/vue/templateString.png" />
<p>
这些字符串会被转为一个可执行Function，
并用new Function（string) 这种方式在  with(this){} 下进行执行<br>
因此不支持eval这种的环境是不可以运行vue的<br>
下面是转化后的with(this)里的内容
<br>
</p>
<img class="example" src="images/vue/withinner.png" />
<pre>
  <code>
//其实这个with里面执行的_c 就是 createElement
vm._c = function (a, b, c, d) { 
  return createElement(vm, a, b, c, d, false); 
};
Vue.prototype._v = createTextVNode;
Vue.prototype._l = renderList;
</code>
</pre>
<p>
在执行这个函数的时候，应为要取各个directive的值，所以会调用到每个值的get句柄，在这个过程中给每一个值的dep添加了whatcher，并返回了value，我想这个时候就是他们建立联系的时候
</p>


<p>
进一步根据这个方法将整个vm数据和模板转化为树形的VNode对象,这就是render返回的VNode类型数据,
这里并不是真实的
<br>
</p>
<img class="example" src="images/vue/vnode.png" />




<pre>
  <code>
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    //可见
    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate');
    }
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(
        vm.$el, vnode, hydrating, false /* removeOnly */,
        vm.$options._parentElm,
        vm.$options._refElm
      );
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    activeInstance = prevActiveInstance;
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };
  </code>
</pre>
</section>
<footer>
    This page was generated by <a href="https://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
</footer>
<script type="text/javascript" src="https://highlightjs.org/static/highlight.site.pack.js"></script>
<script type="text/javascript">
hljs.initHighlightingOnLoad()
</script>
</div>
</div>
</body>

</html>
