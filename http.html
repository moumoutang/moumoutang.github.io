<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-dark.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/tomorrow.css" />
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>vue监听数组变化</title>
</head>

<body>
<div id="container">
  <div class="inner">
      <header>
          <h1>HTTP权威指南记录</h1>
          <h2>ctyunaw</h2>
      </header>
      <section id="downloads" class="clearfix">
          <a href="https://github.com/moumoutang" id="view-on-github" class="button"><span>View on GitHub</span></a>
      </section>
      <hr>
      <section id="main_content">
        <div id="noteContent" class="widget-note fmt" data-lang="markdown">
                                            
<h4>看了几十页才开始想起来记一下笔记了</h4>
<h3 id="articleHeader0">基本的HTTP方法</h3>
<p>一般head和get方法被认为是安全的方法，因为一般他们不需要服务器改变什么，但是在实际中get方法经常被开发者自己乱用，而此时可能就是一个不怎么安全的操作了；</p>
<table>
<thead><tr>
<th align="left">method</th>
<th align="left">DESC</th>
<th align="center">Qty</th>
</tr></thead>
<tbody>
<tr>
<td align="left">GET</td>
<td align="left">GET方法，用于向服务器请求资源；</td>
<td align="center">一般参数就放在url中，返回的内容在body中</td>
</tr>
<tr>
<td align="left">HEAD</td>
<td align="left">跟GET很类似，但是返回的报文中没有body</td>
<td align="center">可以了解资源的情况，是否存在啊，类型啊，通过查看首部看看资源是否被改过（感觉一般是看content-length）</td>
</tr>
<tr>
<td align="left">PUT</td>
<td align="left">向服务器写入文档</td>
<td align="center">在服务器创建以url命名的 body为内容的资源，如果服务器该位置已经存在，则覆盖</td>
</tr>
<tr>
<td align="left">POST</td>
<td align="left">向服务器输入数据</td>
<td align="center">这个就不多说了</td>
</tr>
<tr>
<td align="left">TRACE</td>
<td align="left">顾名思义，就是跟踪</td>
<td align="center">，在一个请求从客户端发出到返回到客户端，会将请求报文放在body中返回回来，来查看报文在经历过整个过程后是否被修改过</td>
</tr>
<tr>
<td align="left">OPTION</td>
<td align="left">请求web服务器告知高中功能</td>
<td align="center"> </td>
</tr>
<tr>
<td align="left">DELETE</td>
<td colspan="2" align="left">删除指定的资源</td>
</tr>
</tbody>
</table>
<p>套接字 socket  指的是对tcp的编程封装，以抽象的方式来编程tcp</p>
<p>tcp三次握手：<br>当两个端需要建立连接的时候，<br>1.客户端会发送一个小的tcp分组，带有SYN标记，表示这是个连接请求；<br>2.服务器收到这个分组后，会回复客户端一个分组  这个分组中SYN和AcK标记都被设置，说明请求已经被接受<br>3.客户端向服务器发送一条确认信息，表示已经建立成功；现在的tcp栈都可以允许在这个分组中发送数据；</p>
<p>我们能看到的只是在建立连接上的时间延时，而看不到具体的三次握手过程</p>
<p>connection：<br>表示本人只看到过connection是keep-alive的状态，其实它还有别的几种值，connection只能用于一段tcp链路，到下一段是要被剥离的，所以基本对于现代的网络来说keep-alive感觉并没有很大很大的作用，对于一些小白的中间代理，更可能使得后面的请求挂起。。。当然聪明的代理会有更聪明的办法理解和解决这个事情</p>
<p>持久链接 vs keep-live<br>http1.1逐渐停止了对keep-alive的支持，用了持久链接来取代；<br>keep-alive是1.0的东西    1.1已经不再支持      1.1所有的连接默认都是持久链接  除非特别指明  在事务处理完以后必须加上connetion:close 来关闭连接<br>但客户端和服务器仍然可以随时关闭空闲的链接，不发送close并不意味服务器承诺永远将连接保持在打开状态</p>
<p>管道连接：<br>将一组请求放在队列中，一个请求到达后，立即发送下一个请求，省去了等待响应的时间</p>
<p>遗留问题：http1的管道连接和http2有啥区别？</p>
<h3 id="articleHeader1">缓存控制</h3>
<p>实体标签 vs 最近修改日期</p>
<p>Etag是对文件某种指纹信息的存储  如果服务器传递了这个  则必须使用实体标签验证器    对应的  If-None-Match<br>Last-Modified  如果服务器提供这个  则应该使用if-modified-since验证<br>如果两者都提供了，客户端应该使用两种方案 这样的话1.0和1.1都可以正确响应</p>
<p>原则上1.1服务器都应该发送实体标签验证器<br>1.1只有收到请求里同时有 if-modified-since和实体标签首部 ，两者都满足，才能返回304</p>
<p>控制缓存：Cache-Control</p>
<p>no-store 禁止缓存对响应进行复制，<br>no-cache 可以存储在本地缓存区域中 只是再次使用的之前必须对源服务器进行再次验证，<br>must-revalidate 严格遵循过期信息，如果没有跟原始服务器进行再验证  不能使用副本 如果原始服务器不可以用 返回504 gateway timeout错误<br>max-age</p>
<p>待续。。。</p>
</div>
      </section>
  </div>
</div>
<footer>
    This page was generated by <a href="https://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
</footer>
<script type="text/javascript" src="https://highlightjs.org/static/highlight.site.pack.js"></script>
<script type="text/javascript">
hljs.initHighlightingOnLoad()
</script>
</body>

</html>